---
title: MP6：系统主时钟（TIM定时中断）配置
date: 2025-02-06 13:33:08
categories: 平衡小车
tags: 平衡小车
top_img: https://img.alicdn.com/i4/2214283073185/O1CN01DUaXAl1ZOmI9WZHla_!!2214283073185.jpg
cover: https://img.alicdn.com/i4/2214283073185/O1CN01DUaXAl1ZOmI9WZHla_!!2214283073185.jpg
---

## MP6：系统主时钟（TIM定时中断）配置

　　经过前5个MP，我们已经配置了很多独立运行的函数，它们都有自己的执行周期。OLED的刷新频率，MPU6050的数据采样频率，卡尔曼滤波的数据处理频率，电机编码盘的数据读取频率，电机速度的刷新频率等等。但若需要它们共同工作，则必须要统一步调。

　　如果我们只是将它们放在while循环内，使之顺序执行，那我们很难得到每一个循环的实际使用时间。我们就难以根据电机编码盘的读数推出电机的转速。同样，我们也难以确定卡尔曼滤波中的T参数。所以我们必须要设置一个给定的运行周期。

　　当然，这个系统主时钟频率也并非越高越好。它受到每个周期中所有程序的运行总时长的约束。若运行总时长高于周期时长，则会出现部分任务挂起、堆积，以及一系列难以预料的问题。同时，也要考虑到是否有独立于该系统时钟的周期性任务，需要确保两者的步调一致。

　　本任务中，需要在周期内依次执行的任务有：读取MPU6050采样得到的数据，将采样数据转化为可计算的标准单位，卡尔曼滤波计算，电机的PID控制（下一节内容），清除相关标志位。OLED可以放在周期内任意位置，也可以放在while循环内，效果相同。放在周期内可以降低单片机处理器占用率，方便后续增加其它内容。**需要特别注意的是，MPU6050的采样频率独立于系统主时钟，需要保证二者周期一致，否则可能出现同一组数据被多次使用，或是连续多组数据只取用了其中一组，致使数据失真。**

　　此外注意，在我们确定了系统主时钟之后，需要据此配置上述函数中未知的内容。包括卡尔曼滤波中的T参数，电机编码盘读取数据后转化为速度所需的采样周期数据，MPU6050的采样频率。

　　因为前面已经使用了TIM1、TIM3、TIM4，所以此处我们使用TIM2作为系统的主时钟。关于频率，个人测试得到的上限频率为50Hz，即每秒执行50次上述运算。但厂家给出的源码中，理论上可以达到200Hz。各位可以自行尝试，如有发现，可以写在评论区，或者发在社团群内。另外，个人测试得，20Hz已足够小车维持平衡。

至此理论上可以自行完成相关配置，请先独立尝试。





　　如果忘记预分频系数、自动重装值与周期之间的关系，请回看任务三。

　　另外，勿忘在main函数开头执行各种初始化函数。

　　在TIM2的中断函数末尾，勿忘`TIM_ClearITPendingBit(TIM2, TIM_IT_Update)`清除TIM2更新事件的中断标志位。
　　下附我编写代码中的TIM2中断函数：

```c
void TIM2_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)		//判断是否是TIM2的更新事件触发的中断
	{
		MPU6050_GetData(&AX, &AY, &AZ, &GX, &GY, &GZ);		//获取MPU6050的数据
		
		/*经测试，采样率50Hz为采样极限*/
		AX2 = AX;
		AY2 = AY;
		AZ2 = AZ;

		
/*角速度方向可能与加速度方向相反，需要在对应参数前加负号*/
/*符号错误的现象是旋转传感器时，角度先往反方向变化，再回调*/
/*这是因为，在产生角度的快速变化时，卡尔曼滤波倾向于相信角速度值，在旋转基本停止后，通过加速度解算出的角度值进行补偿*/
		GX2 = -(GX - sum1.sumgx);
		GY2 = GY - sum1.sumgy;
		GZ2 = GZ - sum1.sumgz;
		
		gyro_balance = GX2;
		
		/*单位转换*/
		AX2 /= 1671.84;							//将加速度测量值转换为m*s^2
		AY2 /= 1671.84;
		AZ2 /= 1671.84;
		GX2 /= 939.8;							//将角速度测量值转换为弧度制	
		GY2 /= 939.8;
		
		/*数据的卡尔曼滤波计算*/
		x = KF_X(AY2, AZ2, GX2)/PI*180;			//将弧度制的计算结果转化为360度制
		y = KF_Y(AX2, AZ2, GY2)/PI*180;
		left = -Read_Encoder(3);				//读取编码盘数值
		right = -Read_Encoder(4);
		
		pwm_balance = get_pwm(x-0.5,gyro_balance);
		pwm_velocity = (int16_t)Velocity(left,right);
		pwm = pwm_balance + pwm_velocity;
		new_flag = 1;
		
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);			//清除TIM2更新事件的中断标志位
	}
}


```

