---
title: EXTI外部中断
date: 2024-06-23 12:49:33
tags: STM32
---

## EXTI外部中断

中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行

中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回

### NVIC优先级分组：

NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级。

抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队。

<img src="https://s2.loli.net/2024/06/23/lz5MEf1JDwHxUvm.png" alt="image-20240623130454582" style="zoom:67%;" />

### EXTI简介：

EXTI（Extern Interrupt）外部中断EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序支持的触发方式：上升沿/下降沿/双边沿/软件触发支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断（如PA1和PB1不可以同时使用）。

<img src="https://s2.loli.net/2024/06/23/4PhqRpjrv2xCFNa.png" alt="image-20240623131326969" style="zoom:67%;" />

### 旋转编码器：

通过旋转产生两个相位相差90°的方波，通过判断哪个方波在前（即先出现下降沿）来判断编码器的旋转方向。编程时，设置两个中断线路，分别判断两个方向的旋转。逻辑为：在出现一个下降沿后，进入中断，再检测另一线路是否在此之后出现下降沿，若出现，则可以判定编码器的旋转方向。

注意，因为外部中断只判断引脚，所以在编码器旋转过一位时，两个引脚都会产生下降沿，即必然进入两个中断程序。例如，在EXTI0先产生下降沿的情况下，程序先进入EXTI0的中断，但因为EXTI1仍为高电平，所以Count不变；而当EXTI1产生下降沿时，检测EXTI0引脚的电平为低，改变Count。所以，虽然两个中断函数都被触发，但只有一个会改变Count值。

但这也需要注意，要让中断函数的执行时间尽可能短，如果在第一个中断函数未执行完时，已经旋转过一位，则会出现第二个中断内条件判断仍然无效的情况。通过设置抢占优先级可以解决一个方向上的问题，但另一方向上仍会出现bug。所以最好的方法就是尽可能缩短程序的执行时间，使之在90°相位差转过前执行完函数，就不会产生冲突了。

```c
/**
  * 函    数：EXTI0外部中断函数
  * 参    数：无
  * 返 回 值：无
  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行
  *           函数名为预留的指定名称，可以从启动文件复制
  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入
  */
void EXTI0_IRQHandler(void)
{
	if (EXTI_GetITStatus(EXTI_Line0) == SET)		//判断是否是外部中断0号线触发的中断
	{
		/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
		{
			if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)		//PB0的下降沿触发中断，此时检测另一相PB1的电平，目的是判断旋转方向
			{
				Encoder_Count --;					//此方向定义为反转，计数变量自减
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line0);			//清除外部中断0号线的中断标志位
													//中断标志位必须清除
													//否则中断将连续不断地触发，导致主程序卡死
	}
}

/**
  * 函    数：EXTI1外部中断函数
  * 参    数：无
  * 返 回 值：无
  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行
  *           函数名为预留的指定名称，可以从启动文件复制
  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入
  */
void EXTI1_IRQHandler(void)
{
	if (EXTI_GetITStatus(EXTI_Line1) == SET)		//判断是否是外部中断1号线触发的中断
	{
		/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
		{
			if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)		//PB1的下降沿触发中断，此时检测另一相PB0的电平，目的是判断旋转方向
			{
				Encoder_Count ++;					//此方向定义为正转，计数变量自增
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line1);			//清除外部中断1号线的中断标志位
													//中断标志位必须清除
													//否则中断将连续不断地触发，导致主程序卡死
	}
}
```

