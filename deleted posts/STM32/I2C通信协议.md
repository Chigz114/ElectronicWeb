---
title: I2C通信协议
date: 2024-06-13 13:45:14
tags: STM32
---

## I2C通信协议

I2C（Inter IC Bus）是由Philips公司开发的一种通用数据总线两根通信线：SCL（Serial Clock）、SDA（Serial Data）

同步，半双工

带数据应答（即收到数据后，会给发送设备一个回复信号）

支持总线挂载多设备（一主多从、多主多从）

同步指的是在发送设备和接收设备间通过时钟线连接，使二者的时钟同步，从而使发送设备可以轻松控制接收设备是否接收。这样，在发送到一半暂停发送时，接收设备因为时钟暂停，也不会继续接收，因而不会出错。但同步时序也因此需要多连接一根时钟线SCL。

相反的，异步则舍弃了这根时钟线，缺点就是发送无法在中途暂停，否则会出现错误。

### 硬件电路：

所有I2C设备的SCL连在一起，SDA连在一起

设备的SCL和SDA均要配置成开漏输出模式

SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右

<img src="https://s2.loli.net/2024/06/13/eXUY7Mxu61thIvS.png" alt="image-20240613140912713" style="zoom:67%;" />

左图是一主多从模型的接线方式。为防止控制输出模式时出现一方高电平，另一方低电平的失误，导致电源短路，I2C通信协议要求设备的SCL和SDA配置为开漏输出模式（代替推挽输出，用浮空状态代替高电平），即无法主动输出高电平。作为替代，由外加电源和上拉电阻提供高电平，保证安全。同时，也避免了输入输出状态的频繁切换。

右图是SCL和SDA的结构。

### I2C时序基本单元：

**起始条件：**SCL高电平期间，SDA从高电平切换到低电平

**终止条件：**SCL高电平期间，SDA从低电平切换到高电平

<img src="https://s2.loli.net/2024/06/13/2l3O719qxkg4FPD.png" alt="image-20240613141815334" style="zoom:50%;" />

**发送一个字节：**SCL低电平期间，主机将数据位依次放到SDA线上（**高位先行**），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节。

主机给SCL置低电平，SDA可以更改数据；更改完成后，SCL置高电平，从机读取数据，SCL再回到低电平，在此期间SDA不可变化。SCL回到低电平后，SDA即可再次改变数据并发送。

如果在发送一半时，主机进入中断，则SCL不再变化，从机也就不会继续读取数据，不会产生错误。

<img src="https://s2.loli.net/2024/06/13/Id8ZXAl2WU6Fuym.png" alt="image-20240613141907851" style="zoom:50%;" />

**接收一个字节：**SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）。

因为I2C的SDA总线是“线与”的，所以主机想接收数据，就需要先设为高电平（实际是高阻抗），这样从机才能用SDA发送数据。

<img src="https://s2.loli.net/2024/06/13/YHq3d56RBLiGvxz.png" alt="image-20240613142517187" style="zoom:50%;" />

发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答。

接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）。

<img src="https://s2.loli.net/2024/06/13/htp9reiSKj46JdY.png" alt="image-20240613142806497" style="zoom:50%;" />

### I2C地址：

在一主多从模式下，为了确定主机调用的是哪个从机，需要发送一个地址，只有与这个地址相同的从机才会应答。I2C的地址模式有7位和10位两种，其中7位地址比较常用。

7位地址中的高4位通常由厂商决定，低3位中的一部分或全部可通过模块上的AD0，AD1等引脚改变。ADx引脚接地则代表该模块的第x位地址为0，从而区分搭载在同一主机上的从机。

在起始位之后，紧跟着的是发送一个位的时序。其中包含7位的地址位和1位的读写位。地址位确定和哪个从机通信，读写位确定是写入从机还是从从机读出。

### I2C时序：

#### 指定地址写：

![image-20240613150704626](https://s2.loli.net/2024/06/13/OKzrvTc9QY72xnl.png)

先写入一个起始位，然后是8位的地址位+读写位，之后是一个应答位（RA，0表示收到，1表示未收到/未应答）。下一个字节指定要写入的从机寄存器地址，即图中的0x19，然后是下一个应答位。再下一个字节是要写入0x19地址位的值，即0xAA，紧跟着一个应答位。最后发送一个停止位，表示结束写入（P）。

#### 当前地址读：

![image-20240613151039197](https://s2.loli.net/2024/06/13/mIL2QwpRGbV58B9.png)

起始位和第一个字节与写入相同。不同的是，“当前地址读”没有指定读取的寄存器地址。它读取的是模块自带指针指向的当前地址，在读取完成后，会进行地址自增，使指针指向下一个地址。在接收数据时，主机的SDA引脚为高电平，从而接收从机的数据（如前所述，I2C的SDA总线是“线与”方式）。在从机发送完一个字节的数据后，会有一个应答位，若主机在应答位拉低SDA电平，则表示需要从机继续发送下一个地址位的寄存器的数据；若主机在应答位保持高电平，则表示结束读取，从机交还SDA控制权限。最后跟上一个停止位。

这里还涉及到一个指定地址+当前地址的操作。如：先使用指定地址写，然后调用当前地址读，此时因为在上一个操作已经改变了从机中地址指针的位置（如改为0x19），并在读取完成后进行地址自增；那么在下一个“当前地址读”操作，读取的就是下一个地址的值（如0x1A）。

#### 指定地址读：

![image-20240613151641458](https://s2.loli.net/2024/06/13/BRJkFMU2CtbalzW.png)

注意，这里的“指定地址读”使用的是一种复合格式，即综合了“指定地址写”和“当前地址读”。这样，一主多从的I2C就只需要2种基础格式了。

起始位和第一个字节与指定地址写相同（**第一个字节的读写位是写入**）。下一个字节用于指定用于读取的从机地址。但与“指定地址写”不同的是，在指定地址后，并不写入数据，而是重启读写（SR）。通过这一操作，就可以指定指针位置，进而实现“指定地址读”。接下来，再进行“当前地址读”操作即可。

这样，就用两种基础操作实现了一种复合操作，而无需额外定义一个“指定地制读”的操作。

在重启那一步之前，也可以加入一个停止步骤，效果也是一样的。

#### 读写多个字节：

上面三种方式，都是读写一个字节。如果需要读写多个字节，只需要将最后的数据部分多重复几次，在应答位置0（即应答），即可实现连续读写（因为写入一个字节后，寄存器地址就会自动+1）；在读写到最后一位时将应答位置1（即非应答）即可。



### I2C的软件和硬件协议：

**软件协议：**直接控制GPIO引脚产生通讯时序，由GPIO控制每个时刻的引脚状态。

**硬件协议：**由STM32上的I2C片上外设专门负责实现I2C通讯协议，只需要配置好外设，就可以自动通过协议要求产生通讯信号，收发数据并缓存，CPU只需要检测外设的工作状态和访问数据寄存器，就可以完成数据收发。

硬件协议的方式减轻CPU工作量，且使软件设计更加简单。
